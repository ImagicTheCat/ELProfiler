= ELProfiler
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]
:toc: left
:toclevels: 5

Embeddable Lua Profiler is a pure Lua library designed to profile Lua code.

NOTE: The `debug` library already has limitations; but when using a more sophisticated environment like LuaJIT, the results can be even more difficult to interpret. This library only aims to be a basic Lua code profiler by focusing on reliable data given by the VM instead of finding tricks to measure everything (like C calls).

TIP: LuaJIT 2.1.x has a built-in profiler more suited than this library; profiling with disabled optimizations is probably not desired and this library can't profile most of LuaJIT optimizations (even with the JIT compiler disabled).

== Data

The profiler will listen to `call` and `return` hook events of the `debug` library. Collected data is organized into blocks; each block represents something with a beginning and eventually an end. Each beginning is a call and when an end occurs, the approximated time spent in the block is computed.

.Blocks
[horizontal]
function:: each captured function call create a block of id `what:namewhat:name:short_src:linedefined` as described at https://www.lua.org/pil/23.1.html
record:: the record block is defined by the space between `start()` and `stop()`
section:: defined by calls to `sb()` and `se()`

TIP: Blocks may include other blocks, `block.time-block.sub_time` will give insight on the time spent in the block itself, excluding recorded sub blocks.

.Modes
[horizontal]
hook:: use debug hook events
manual:: no events, manual measures (sections)

NOTE: Manual measures are probably not what you expect from a profiler, but they can be useful to manually investigate performance when other methods don't give useful results. For example, they may get compiled by LuaJIT and may not prevent the JIT compilation of the profiled code.

TIP: `os.clock()` is NYI in LuaJIT 2.0.x, you may need to use a more precise and compilable clock function to that purpose.

NOTE: Using sections in `hook` mode is possible, but the section stack doesn't mix with the Lua call stack.

WARNING: A measure of 0 or a call depth different from 0 is a hint that the measure is probably wrong.

=== Edge cases

.Sub time
----
A
  B
    A
    A
  B
A

Currently, the sub time for the same nested block is not correctly computed.
----

.Wrong stack
----
A
  B
  A
B

depth ~= 0 may detect missing/additional begin/end, but it will not detect other incorrect stack patterns (which should only occur when using sections in manual mode).
----

== API

[source, lua]
----
-- set clock function
-- the default function is os.clock
-- f_clock(): should return the current execution time reference (a number)
ELProfiler.setClock(f_clock)

-- start profiling
-- mode: string
--- "hook": debug hook events (default)
--- "manual": no events, manual sections sb/se
ELProfiler.start(mode)

-- stop profiling
-- return profile data {}
--- blocks: map of block id => block
---- block: {}
----- id: block id
----- depth: call depth, 0 is valid
----- calls: number of call
----- time: time spent
----- sub_time: time spent by sub blocks
----- sub_blocks: map of block => data
------ data: {}
------- calls: number of call of this sub block inside this block
------- time: time spent in this sub block inside this block
ELProfiler.stop()

-- section begin
-- id: custom block id
ELProfiler.sb(id)

-- section end
ELProfiler.se()

-- create text report from profile data
-- mode: (optional) string
--- "spent_tree": (default) blocks by descending time spent with sub blocks (+calls), (!) signals a depth ~= 0
--- "real_list": blocks by descending "real" time spent (+calls), (!) signals a depth ~= 0
-- threshold: (optional) minimum time factor (0.01 => 1%) required for a block to be displayed (default -1)
-- return formatted string
ELProfiler.format(profile_data, mode, threshold)
----
